Реализуйте файловую систему на базе одного файла (все данные должны храниться внутри одного файла). Должна быть поддержка по крайней мере для операций создания, удаления файлов, а также чтения, записи контента. Должен быть документированный API для работы с файловой системой.
Для реализации желательно использовать платформу Java или .Net. Код должен быть production качества, в том числе с тестами. 
Оценивается правильность работы программы, производительность, качество кода, дизайн системы и API. 
Папки есть в любой FS, так что их лучше сделать.
Переименование, копирование, перемещение по желанию, с учетом того, что будут операции над файлами и папками как – создание, чтение, запись, удаление.
Хочется не проверять все это руками а иметь набор функциональных тестов на API для этих сценариев.
Хотелось бы иметь возможность померить производительность FS в сравнении с производительностью реальной FS.
И увидеть, что все хорошо в случае крайних условий: большие и маленькие файлы, большое количество файлов, большое количество потоков, одновременно выполняющих операции на FS/над одними и теми же папками и файлами.



Нужно иметь дерево каталогов. В каждом каталоге ссылки на файлы (дерево просто как дерево или как B+ ?). Т.к. файлы будут битые на батчи, то надо дерево батчей для каждого файла (тут уже точно B+ ?).
Нужен журнал действий.
Лучше иметь представление FS такое: сначала дерево файлов, потом сами файлы последовательно.
Бить файлы на кластеры или не бить? Если не бить, то при добавлении в файл его придётся переносить. Будем бить.
Добавление нового файла известного размера происходит так:
    Проверка допустимого максимального размера.
    Запись в журнал о намерении записать файл.
    Лок на дерево, поиск места куда, создаём запись в дерево, записываем в журнал куда именно будем записывать первый блок, отдаём лок на дерево. На выходе имеем ноду файла в дереве и ссылку на первый блок.
    Если файл маленький, то можно всё его содержимое вписать в ноду.
    Пишем последовательно по блокам: пишем, ищем незанятый, занимаем, записываем в ноду, дописываем в блок и т.д.
    Удаляем из журнала запись о намерении.

Запись в существующий файл



В начале диска есть спец данные:
версия драйвера
переменные.

Всё побито на кластеры.
Каждая ентри состоит из:
    Флага про тип энтри
    имя
    нужных дат
    данные этой ентри
    
Данные для файла трёх видов:
    Если помещаются в кластер ентри, то внутри ентри - резидентные
    Если не помещаются в кластер ентри, но нашлись кластеры, такие, что можно в виде датаранов положить в дату, то записываюстя датараны
    Если не помещаются в кластер ентри и датараны не помещаются в кластер ентри, то список кластеров с датаранами
    
В начале идёт ентри корневой директории
    
    
    
    
Каждая запись бьётся на команды максимально большой непрерывной размерности, но с ограничением сверху
Есть один писатель для данных, он берёт команду из очереди и пишет её
Есть отдельный механизм записать битовую маску на диск - он внутри контроллера битовой маски
Есть один читатель, читает по командам, есть ограничение сверху

